#include "pgsql-connection.h"
#include "pgsql-result.h"
#include "hphp/runtime/base/array-iterator.h"

namespace HPHP {
namespace Pgsql {

PreparedParameters::PreparedParameters() {}

PreparedParameters::PreparedParameters(Array const & params)
        : params_((ssize_t)params.size()) {
    unsigned i = 0;
    std::vector<ssize_t> positions((ssize_t)params.size());
    for (ArrayIter param(params); param; ++param, ++i) {
        if (param.second().isNull()) {
            positions[i] = std::string::npos;
        } else {
            auto str = param.second().toString();
            auto currentBufferPos = paramBuffer_.size();
            std::copy(str.c_str(), str.c_str() + str.length() + 1, std::back_inserter(paramBuffer_));
            positions[i] = currentBufferPos;
        }
    }

    for (unsigned i = 0; i < positions.size(); i++) {
        if (positions[i] == std::string::npos) {
            params_[i] = nullptr;
        } else {
            params_[i] = paramBuffer_.data() + positions[i];
        }
    }
}




ConnectionResource::ConnectionResource(Array params) {
    beginConnection(params);
    auto debug = fopen("/home/norbyte/debug.log", "rw+");
    PQtrace (connection_, debug);
}

ConnectionResource::~ConnectionResource() {
    if (connection_ != nullptr) {
        PQfinish(connection_);
    }
}

/**
 * Poll libpq so that it can proceed with the connection sequence.
 */
ConnectionResource::PollingStatus ConnectionResource::pollConnection() {
    // LOG(INFO) << "PQconnectPoll()";
    switch (PQconnectPoll(connection_)) {
        case PGRES_POLLING_FAILED:  return PollingStatus::Failed;
        case PGRES_POLLING_READING: return PollingStatus::Reading;
        case PGRES_POLLING_WRITING: return PollingStatus::Writing;
        case PGRES_POLLING_OK:      return PollingStatus::Ok;
        default:
            throw EnigmaException("Unknown value returned from PQconnectPoll()");
    }
}

/**
 * Reset the communication channel to the server, in a nonblocking manner.
 */
void ConnectionResource::resetStart() {
    LOG(INFO) << "PQresetStart()";
    if (PQresetStart(connection_) != 1) {
        throw EnigmaException(std::string("Failed to reset connection: ") + errorMessage());
    }
}

/**
 * Poll libpq so that it can proceed with the reset sequence.
 */
ConnectionResource::PollingStatus ConnectionResource::pollReset() {
    LOG(INFO) << "PQresetPoll()";
    switch (PQresetPoll(connection_)) {
        case PGRES_POLLING_FAILED:  return PollingStatus::Failed;
        case PGRES_POLLING_READING: return PollingStatus::Reading;
        case PGRES_POLLING_WRITING: return PollingStatus::Writing;
        case PGRES_POLLING_OK:      return PollingStatus::Ok;
        default:
            throw EnigmaException("Unknown value returned from PQresetPoll()");
    }
}

/**
 * Returns the status of the connection.
 */
ConnectionResource::Status ConnectionResource::status() const {
    LOG(INFO) << "PQstatus()";
    switch (PQstatus(connection_)) {
        case CONNECTION_OK:  return Status::Ok;
        case CONNECTION_BAD: return Status::Bad;
            // The rest of the CONNECTION_ statuses are only used during asynchronous connection
        default:
            return Status::Pending;
    }
}

/**
 * Returns the current in-transaction status of the server.
 */
ConnectionResource::TransactionStatus ConnectionResource::transactionStatus() const {
    LOG(INFO) << "PQtransactionStatus()";
    switch (PQtransactionStatus(connection_)) {
        case PQTRANS_IDLE:    return TransactionStatus::Idle;
        case PQTRANS_ACTIVE:  return TransactionStatus::Active;
        case PQTRANS_INTRANS: return TransactionStatus::InTransaction;
        case PQTRANS_INERROR: return TransactionStatus::InError;
        case PQTRANS_UNKNOWN: return TransactionStatus::Unknown;
        default:
            throw EnigmaException("Unknown value returned from PQtransactionStatus()");
    }
}

bool ConnectionResource::inTransaction() const {
    auto state = transactionStatus();
    return state == TransactionStatus::Active ||
            state == TransactionStatus::InTransaction ||
            state == TransactionStatus::InError;
}

/**
 * Looks up a current parameter setting of the server.
 */
Variant ConnectionResource::parameterStatus(String const & param) const {
    auto value = PQparameterStatus(connection_, param.c_str());
    if (value == nullptr) {
        return Variant(Variant::NullInit{});
    } else {
        return String(value);
    }
}

/**
 * Returns the error message most recently generated by an operation on the connection.
 */
std::string ConnectionResource::errorMessage() const {
    auto message = PQerrorMessage(connection_);
    if (message == nullptr) {
        return std::string();
    } else {
        return std::string(message);
    }
}

/**
 * Obtains the file descriptor number of the connection socket to the server.
 */
int ConnectionResource::socket() const {
    return PQsocket(connection_);
}

/**
 * Returns the process ID (PID) of the backend process handling this connection.
 */
int ConnectionResource::backendPid() const {
    return PQbackendPID(connection_);
}

/**
 * Submits a command to the server without waiting for the result(s).
 */
void ConnectionResource::sendQuery(String const & command) {
    LOG(INFO) << "PQsendQuery()";
    if (PQsendQuery(connection_, command.c_str()) != 1) {
        throw EnigmaException(std::string("Failed to send query: ") + errorMessage());
    }
}

/**
 * Submits a command and separate parameters to the server without waiting for the result(s).
 */
void ConnectionResource::sendQueryParams(String const & command, PreparedParameters const & params) {
    LOG(INFO) << "PQsendQueryParams()";
    if (PQsendQueryParams(connection_, command.c_str(), params.count(), nullptr, params.buffer(), nullptr, nullptr, 0) != 1) {
        throw EnigmaException(std::string("Failed to send query: ") + errorMessage());
    }
}

/**
 * Sends a request to create a prepared statement with the given parameters, without waiting for completion.
 */
void ConnectionResource::sendPrepare(String const & command, String const & stmtName, int numParams) {
    LOG(INFO) << "PQsendPrepare()";
    if (PQsendPrepare(connection_, command.c_str(), stmtName.c_str(), numParams, nullptr) != 1) {
        throw EnigmaException(std::string("Failed to prepare statement: ") + errorMessage());
    }
}

/**
 * Sends a request to execute a prepared statement with given parameters, without waiting for the result(s).
 */
void ConnectionResource::sendQueryPrepared(String const & stmtName, PreparedParameters const & params) {
    LOG(INFO) << "PQsendQueryPrepared()";
    if (PQsendQueryPrepared(connection_, stmtName.c_str(), params.count(), params.buffer(), nullptr, nullptr, 0) != 1) {
        throw EnigmaException(std::string("Failed to send prepared query: ") + errorMessage());
    }
}

/**
 * Submits a request to obtain information about the specified prepared statement, without waiting for completion.
 */
void ConnectionResource::sendDescribePrepared(String const & stmtName) {
    LOG(INFO) << "PQsendDescribePrepared()";
    if (PQsendDescribePrepared(connection_, stmtName.c_str()) != 1) {
        throw EnigmaException(std::string("Failed to describe prepared statement: ") + errorMessage());
    }
}

/**
 * Waits for the next result from a prior sendQuery, sendQueryParams, sendPrepare, or
 * sendQueryPrepared call, and returns it.
 * A null pointer is returned when the command is complete and there will be no more results.
 */
std::unique_ptr<ResultResource> ConnectionResource::getResult() {
    LOG(INFO) << "PQgetResult()";
    auto result = PQgetResult(connection_);
    if (result == nullptr) {
        return std::unique_ptr<ResultResource>();
    } else {
        /*
         * We don't support multiple result sets, so discard all
         * subsequent PQresult-s
         */
        while (auto discarded = PQgetResult(connection_)) {
            PQclear(discarded);
        }

        return std::unique_ptr<ResultResource>(
                new ResultResource(result));
    }
}

/**
 * If input is available from the server, consume it.
 *
 * Returns false if a command is busy, that is, getResult() would block waiting for input
 */
bool ConnectionResource::consumeInput() {
    // LOG(INFO) << "PQconsumeInput()";
    if (PQconsumeInput(connection_) != 1) {
        throw EnigmaException(std::string("Failed to process server response: ") + errorMessage());
    }

    return PQisBusy(connection_) != 1;
}

/**
 * Attempts to flush any queued output data to the server.
 *
 * Returns true if successful, or false if it was unable to send all the data in the send queue yet.
 */
bool ConnectionResource::flush() {
    LOG(INFO) << "flush()";
    switch (PQflush(connection_)) {
        case 0:
            return true;
        case 1:
            return false;
        default:
            throw EnigmaException(std::string("Failed to flush connection: ") + errorMessage());
    }
}

void ConnectionResource::cancel() {
    char errbuf[256];
    auto cancel = PQgetCancel(connection_);
    LOG(INFO) << "PQcancel()";
    bool canceled = PQcancel(cancel, errbuf, sizeof(errbuf)) == 1;
    PQfreeCancel(cancel);
    if (!canceled) {
        throw EnigmaException(std::string("Failed to cancel query: ") + errbuf);
    }
}

/**
 * Convert an array to a list of raw (const char *) strings.
 * The string vectors must be preallocated to hold at least [values.length()] elements.
 */
void ConnectionResource::arrayToStringList(Array const & values, req::vector<String> & strings,
                                           req::vector<const char *> & ptrs, bool allowNulls) {
    unsigned i = 0;
    for (ArrayIter param(values); param; ++param, ++i) {
        if (allowNulls && param.second().isNull()) {
            ptrs[i] = nullptr;
        } else {
            strings[i] = param.second().toString();
            ptrs[i] = strings[i].c_str();
        }
    }
}

void ConnectionResource::beginConnection(Array const & params) {
    ssize_t n_params = params.length();
    req::vector<String> keys(n_params), values(n_params);
    req::vector<const char *> pg_keys(n_params + 1), pg_values(n_params + 1);

    unsigned i = 0;
    for (ArrayIter iter(params); iter; ++iter, ++i) {
        keys[i] = iter.first().toString();
        pg_keys[i] = keys[i].c_str();

        values[i] = iter.second().toString();
        pg_values[i] = values[i].c_str();
    }

    pg_keys[i] = nullptr;
    pg_values[i] = nullptr;

    LOG(INFO) << "PQconnectStartParams()";
    connection_ = PQconnectStartParams(pg_keys.data(), pg_values.data(), 0);
    if (connection_ == nullptr) {
        throw EnigmaException("Failed to initialize pgsql connection");
    }

    if (PQsetnonblocking(connection_, 1) != 0) {
        throw EnigmaException("Failed to set nonblocking mode on connection");
    }
}

} // namespace Pgsql
} // namespace HPHP
