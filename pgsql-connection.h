#ifndef HPHP_PGSQL_CONNECTION_H
#define HPHP_PGSQL_CONNECTION_H

#include "hphp/runtime/ext/extension.h"
#include <libpq-fe.h>
#include "enigma-common.h"

namespace HPHP {

class EnigmaException : public std::runtime_error {
public:
    inline EnigmaException(std::string const & msg)
            : std::runtime_error(msg) {}
};

namespace Pgsql {

class ResultResource;
typedef std::unique_ptr<ResultResource> p_ResultResource;

class PreparedParameters {
public:
    PreparedParameters();
    PreparedParameters(PreparedParameters const & prepared);
    PreparedParameters(Array const & params);

    inline int count() const {
        return params_.size();
    }

    inline const char * const * buffer() const {
        return params_.data();
    }

private:
    std::string paramBuffer_;
    req::vector<const char *> params_;
};

enum class ConnectionInit {
    InitAsync,
    InitSync
};

typedef std::map<std::string, std::string> ConnectionOptions;

class ConnectionResource {
public:
    enum class PollingStatus {
        Failed,  // indicates the connection procedure has failed
        Reading, // should wait until the socket is ready to read
        Writing, // should wait until the socket is ready to write
        Ok       // indicates the connection has been successfully made
    };

    enum class Status {
        Ok,
        Bad,
        Pending
    };

    enum class TransactionStatus {
        Idle,          // currently idle
        Active,        // a command is in progress
        InTransaction, // idle, in a valid transaction block
        InError,       // idle, in a failed transaction block
        Unknown        // reported if the connection is bad
    };

    ConnectionResource(ConnectionOptions const & params, ConnectionInit initType);

    ~ConnectionResource();

    /**
     * Poll libpq so that it can proceed with the connection sequence.
     */
    PollingStatus pollConnection();

    /**
     * Reset the communication channel to the server.
     */
    void reset();

    /**
     * Reset the communication channel to the server, in a nonblocking manner.
     */
    void resetStart();

    /**
     * Poll libpq so that it can proceed with the reset sequence.
     */
    PollingStatus pollReset();

    /**
     * Returns the status of the connection.
     */
    Status status() const;

    /**
     * Returns the current in-transaction status of the server.
     */
    TransactionStatus transactionStatus() const;

    /**
     * Returns the current in-transaction status of the server.
     */
    bool inTransaction() const;

    /**
     * Looks up a current parameter setting of the server.
     */
    Variant parameterStatus(String const & param) const;

    /**
     * Returns the error message most recently generated by an operation on the connection.
     */
    std::string errorMessage() const;

    /**
     * Obtains the file descriptor number of the connection socket to the server.
     */
    int socket() const;

    /**
     * Returns the process ID (PID) of the backend process handling this connection.
     */
    int backendPid() const;

    /**
     * Submits a command to the server waits for the result.
     */
    p_ResultResource query(String const & command);

    /**
     * Submits a command to the server and waits for the result, with the ability to pass parameters separately from the SQL command text.
     */
    p_ResultResource queryParams(String const & command, PreparedParameters const & params, bool binary);

    /**
     * Submits a request to create a prepared statement with the given parameters, and waits for completion.
     */
    p_ResultResource prepare(String const & stmtName, String const & command, int numParams);

    /**
     * Sends a request to execute a prepared statement with given parameters, and waits for the result.
     */
    p_ResultResource queryPrepared(String const & stmtName, PreparedParameters const & params, bool binary);

    /**
     * Submits a request to obtain information about the specified prepared statement, and waits for completion.
     */
    p_ResultResource describePrepared(String const & stmtName);

    /**
     * Submits a command to the server without waiting for the result(s).
     */
    void sendQuery(String const & command);

    /**
     * Submits a command and separate parameters to the server without waiting for the result(s).
     */
    void sendQueryParams(String const & command, PreparedParameters const & params, bool binary);

    /**
     * Sends a request to create a prepared statement with the given parameters, without waiting for completion.
     */
    void sendPrepare(String const & stmtName, String const & command, int numParams);

    /**
     * Sends a request to execute a prepared statement with given parameters, without waiting for the result(s).
     */
    void sendQueryPrepared(String const & stmtName, PreparedParameters const & params, bool binary);

    /**
     * Submits a request to obtain information about the specified prepared statement, without waiting for completion.
     */
    void sendDescribePrepared(String const & stmtName);

    /**
     * Waits for the next result from a prior sendQuery, sendQueryParams, sendPrepare, or
     * sendQueryPrepared call, and returns it.
     * A null pointer is returned when the command is complete and there will be no more results.
     */
    std::unique_ptr<ResultResource> getResult();

    /**
     * If input is available from the server, consume it.
     *
     * Returns false if a command is busy, that is, getResult() would block waiting for input
     */
    bool consumeInput();

    /**
     * Attempts to flush any queued output data to the server.
     *
     * Returns true if successful, or false if it was unable to send all the data in the send queue yet.
     */
    bool flush();

    void cancel();

    // TODO: notifies
    // TODO: copy
    // TODO: notice processing

private:
    PGconn *connection_{nullptr};

    /**
     * Convert an array to a list of raw (const char *) strings.
     * The string vectors must be preallocated to hold at least [values.length()] elements.
     */
    void arrayToStringList(Array const & values, req::vector<String> & strings, req::vector<const char *> & ptrs,
                           bool allowNulls = false);

    void beginConnection(ConnectionOptions const & params, ConnectionInit initType);
};

}
}

#endif //HPHP_PGSQL_CONNECTION_H
